# MÓDULO 1 — SINCRONIZACIÓN ENTRE TAREAS

## Objetivo

Aprender a **coordinar tareas** y **proteger recursos compartidos** usando los dos mecanismos básicos de FreeRTOS:

1. **Semáforos binarios** → sincronización por evento.
2. **Mutex (mutual exclusion)** → protección de acceso a un recurso común.

## Contexto

En un sistema multitarea (como el ESP32 con FreeRTOS), **las tareas se ejecutan concurrentemente**, y puede haber conflictos si dos acceden al mismo recurso (por ejemplo, el puerto `Serial` o una variable global).
También puede ser necesario que una tarea *espere a que otra haga algo*, por ejemplo:

* esperar que se presione un botón,
* esperar que un sensor termine de leer,
* esperar que se complete una transmisión.

## 1. Semáforo binario (sincronización por evento)

### Concepto

Un **semáforo binario** se comporta como una **bandera de evento**:
una tarea o una ISR la “levanta” (`xSemaphoreGive()`), y otra la “toma” (`xSemaphoreTake()`).

Es ideal para *decirle a una tarea que algo ocurrió*, sin usar `delay()` ni polling.

### Proyecto: Botón → LED (sin `delay()`)

* El botón (GPIO 0) genera una interrupción.
* La ISR “da” el semáforo.
* Una tarea espera el semáforo, y cuando lo recibe, cambia el estado del LED.

| Elemento                   | Rol                                                           |
| -------------------------- | ------------------------------------------------------------- |
| `xSemaphoreCreateBinary()` | Crea el semáforo                                              |
| `xSemaphoreGiveFromISR()`  | Lo activa desde una ISR                                       |
| `xSemaphoreTake()`         | Lo espera en una tarea                                        |
| `portMAX_DELAY`            | Espera infinita                                               |
| `IRAM_ATTR`                | Asegura que la ISR se ejecute desde RAM          |
| `portYIELD_FROM_ISR()`     | Permite cambiar de tarea inmediatamente si la ISR lo requiere |

Esto reemplaza al clásico:

```cpp
if (digitalRead(btn) == LOW) {
  // hacer algo
  delay(100);
}
```

Sin bloqueos, con respuesta inmediata, y escalable a sistemas con más eventos o sensores.

## 2. Mutex (protección de recursos compartidos)

### Concepto

Un **mutex** (mutual exclusion) evita que dos tareas accedan al mismo recurso a la vez.
Solo una puede **“tomarlo”** (`xSemaphoreTake()`), y debe **“liberarlo”** (`xSemaphoreGive()`). Es ideal para proteger:

* escritura en `Serial`,
* acceso a una pantalla,
* escritura en un archivo o SD,
* variables globales compartidas.

### Proyecto: Dos tareas escriben en Serial

* Una tarea escribe `"Tarea 1"` cada 500 ms.
* Otra escribe `"Tarea 2"` cada 700 ms.
* Sin mutex → los mensajes se mezclan.
* Con mutex → los mensajes salen completos y ordenados.

| Elemento                  | Rol                                     |
| ------------------------- | --------------------------------------- |
| `xSemaphoreCreateMutex()` | Crea un mutex exclusivo                 |
| `xSemaphoreTake()`        | Bloquea hasta que el recurso esté libre |
| `xSemaphoreGive()`        | Libera el recurso                       |
| `portMAX_DELAY`           | Espera infinita                         |
| `vTaskDelay()`            | Controla el ritmo de ejecución          |

El mutex **no sincroniza eventos**, sino **protege recursos**.
Mientras que el semáforo binario **avisa que algo pasó**, el mutex **evita que pase algo indebido al mismo tiempo**.

## Ejercicio Integrador

Unir ambos conceptos:

* ISR con botón → da un semáforo.
* La tarea del botón, cuando lo toma, accede a `Serial` protegido con un mutex. El patrón real es: **evento → acceso seguro a recurso compartido**.