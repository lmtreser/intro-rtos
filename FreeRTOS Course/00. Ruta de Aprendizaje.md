# RUTA DE APRENDIZAJE FREERTOS

**Plataforma:** ESP32

**Entorno:** PlatformIO / Arduino Framework

**Objetivos:** lograr dominio en el diseño concurrente profesional, con comunicación eficiente entre tareas, recursos compartidos y control de flujo.

## MÓDULO 1 — Sincronización entre tareas

### Objetivo:

Aprender a **coordinar tareas sin usar delays** innecesarios, y **evitar conflictos** al acceder a recursos comunes.

### Proyecto 1: Semáforo binario

**Ejemplo:** Un botón físico (GPIO) genera una interrupción → una tarea prende o apaga un LED. Aprenderá:

* Cómo comunicar una ISR con una tarea sin bloqueos.
* Cómo evitar usar `delay()` o polling.

### Proyecto 2: Mutex

**Ejemplo:** Dos tareas escriben en el mismo puerto Serial. Cada una toma un `xSemaphoreCreateMutex()` antes de escribir. Aprenderá:

* Qué es una “región crítica”.
* Cómo evitar mensajes mezclados o corrupción de datos.

## MÓDULO 2 — Temporización y timers de software

### Objetivo:

Usar **timers internos de FreeRTOS** para tareas periódicas livianas, sin crear hilos adicionales.

### Proyecto 3: Timer periódico

**Ejemplo:** Un timer cada 2 segundos llama una función que lee un sensor DHT22. La tarea principal solo imprime los valores actualizados. Aprenderá:

* Cómo crear, iniciar y detener un `TimerHandle_t`.
* Qué diferencia hay con usar `vTaskDelay()` en un bucle infinito.

## MÓDULO 3 — Notificaciones directas a tareas

### Objetivo:

Transmitir datos o eventos entre tareas sin colas.

### Proyecto 4: Notificación directa

**Ejemplo:** Una tarea lee un sensor → notifica a otra que actualiza el LCD. Aprenderá:

* Cuándo conviene reemplazar colas por notificaciones.
* Cómo pasar valores simples (por ejemplo, flags o contadores).

## MÓDULO 4 — ISR + FreeRTOS + eventos

### Objetivo:

Combinar **interrupciones físicas** (botones, sensores, UART) con tareas controladas por RTOS.

### Proyecto 5: Interrupción externa

**Ejemplo:** Un sensor de movimiento (PIR) dispara una ISR que activa una tarea de registro o alarma. Aprenderá:

* Las funciones `FromISR()`.
* Prioridades correctas de interrupciones.
* Comunicación determinista entre hardware y software.

## MÓDULO 5 — Recursos compartidos y diseño modular

### Objetivo:

Diseñar componentes autónomos (clases) que contengan su propia tarea y compartan recursos protegidos.

### Proyecto 6: Clases con tareas internas

**Ejemplo:** Clase `DHTSensorTask`, clase `LCDTask`, clase `SerialLoggerTask`, cada una con su propia `xTaskCreate()` interna y una cola o semáforo compartido. Aprenderá:

* Cómo pasar `this` como puntero a tarea.
* Cómo encapsular lógica FreeRTOS dentro de clases.

## MÓDULO 6 — Estado del sistema y máquinas de estado

### Objetivo:

Coordinar varios modos de funcionamiento dentro de un mismo firmware.

### Proyecto 7: Sistema con modos

**Ejemplo:** Un sistema con tres estados: `IDLE`, `MONITOR`, `ALARM`.
Cada tarea actúa distinto según el estado global. Aprenderá:

* Cómo representar estados (enum class, switch).
* Cómo comunicar eventos entre tareas con colas o flags.
* Cómo centralizar la lógica de control.

## MÓDULO 7 — Optimización, monitoreo y diagnóstico

### Objetivo:

Entender cómo medir, optimizar y depurar el comportamiento de FreeRTOS.

### Proyecto 8: Monitoreo de recursos

**Ejemplo:** Crear una tarea “watchdog” que cada 5 segundos imprime el **uso de stack y memoria** de cada tarea. Aprenderá:

* Detección de desbordes de stack.
* Medición de carga de CPU.
* Ajuste de prioridades y tamaño de stack.

## MÓDULO 8 — Integración con IoT / Comunicación en red

### Objetivo:

Integrar FreeRTOS con tareas de comunicación (WiFi, MQTT, HTTP).

### Proyecto 9: Tarea de red

**Ejemplo:** Una tarea de red lee una cola de sensores y publica los valores vía MQTT. Aprenderá:

* Cómo separar la lógica de red del resto del sistema.
* Sincronización y reconexión sin bloquear otras tareas.

## MÓDULO 9 — Proyecto final

### Objetivo:

Diseñar un **sistema embebido concurrente completo**.

### Proyecto 10: “Estación de monitoreo ambiental”

Integración de diversos componentes, tales como:

* DHT22 (sensor)
* LCD I2C (display)
* LED de estado
* Botón de modo
* Comunicación serie o MQTT
* Control de energía / sleep
