# M√ìDULO 3 ‚Äî NOTIFICACIONES DIRECTAS ENTRE TAREAS

üéØ Objetivo

Aprender a usar las notificaciones directas de FreeRTOS para enviar datos o se√±ales entre tareas,
de forma m√°s r√°pida y ligera que con colas o sem√°foros.


---

üß† Concepto clave

Cada tarea en FreeRTOS tiene un espacio de notificaci√≥n interno, una especie de registro privado (como una variable interna protegida por el RTOS).
Pod√©s usarlo para:

1. Sincronizaci√≥n (avisar a otra tarea que algo ocurri√≥).


2. Transferencia de datos simples (enteros, flags, etc.).


3. Reemplazar colas cuando hay comunicaci√≥n uno a uno.




---

üßÆ Diferencias con colas

Mecanismo	Permite enviar	Tama√±o	Destinatarios	Velocidad

Cola (xQueueSend)	Estructuras completas	Variable	Varios	Media
Notificaci√≥n directa	Un valor (uint32_t)	4 bytes	1 tarea	‚ö°Ô∏è Alta



---

‚öôÔ∏è Escenario pr√°ctico

Queremos que el sistema:

tenga una tarea que lea el DHT22 peri√≥dicamente;

esa tarea notifique a otra que hay nuevos datos disponibles;

la segunda tarea muestre por Serial y LCD los valores.


üëâ Sin colas, sin estructuras compartidas.
Solo usando notificaciones directas y variables globales protegidas.


---

üíª C√≥digo completo

#include <Arduino.h>
#include <DHT.h>
#include <LiquidCrystal_I2C.h>

constexpr uint8_t DHT_PIN  = 4;
constexpr uint8_t DHT_TYPE = DHT22;

DHT dht{DHT_PIN, DHT_TYPE};
LiquidCrystal_I2C lcd{0x27, 16, 2};

// Handle de las tareas
TaskHandle_t xSensorTaskHandle = nullptr;
TaskHandle_t xDisplayTaskHandle = nullptr;

// Estructura compartida (simple, sin cola)
struct SensorData {
  float temperature;
  float humidity;
};

SensorData currentData;

// Tarea lectora del sensor
void TaskReadSensor(void* pvParameters) {
  (void) pvParameters;

  for (;;) {
    currentData.temperature = dht.readTemperature();
    currentData.humidity    = dht.readHumidity();

    // Notificar a la tarea de display que hay nuevos datos
    xTaskNotifyGive(xDisplayTaskHandle);

    vTaskDelay(pdMS_TO_TICKS(2000));
  }
}

// Tarea que muestra datos en Serial y LCD
void TaskDisplay(void* pvParameters) {
  (void) pvParameters;

  for (;;) {
    // Esperar notificaci√≥n (bloquea hasta recibir)
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.printf("Temp: %.1f C", currentData.temperature);
    lcd.setCursor(0, 1);
    lcd.printf("Hum: %.1f %%", currentData.humidity);

    Serial.printf("Temp: %.2f ¬∞C | Hum: %.2f %%\n", currentData.temperature, currentData.humidity);
  }
}

void setup() {
  Serial.begin(115200);
  lcd.init();
  lcd.backlight();
  dht.begin();

  xTaskCreate(TaskReadSensor, "Sensor", 2048, NULL, 1, &xSensorTaskHandle);
  xTaskCreate(TaskDisplay, "Display", 2048, NULL, 2, &xDisplayTaskHandle);
}

void loop() {}


---

üîç An√°lisis del flujo

1. TaskReadSensor() lee el DHT22 cada 2 s.


2. Guarda los datos en la variable global currentData.


3. Llama a xTaskNotifyGive() para avisar a la tarea de display.


4. TaskDisplay() est√° bloqueada en ulTaskNotifyTake().


5. Cuando recibe la se√±al, actualiza LCD y Serial.




---

‚öñÔ∏è Ventajas sobre colas

‚úÖ No hay copia de estructuras (usa una sola variable global).
‚úÖ No hay bloqueos de memoria ni sobrecarga.
‚úÖ Comunicaci√≥n directa y sin intermediarios.
‚úÖ Ideal para flujos uno a uno (productor ‚Üí consumidor).


---

‚ö†Ô∏è Cu√°ndo no usarlas

Si m√°s de una tarea necesita los datos.

Si necesit√°s mantener un historial (varios elementos en buffer).

Si los datos requieren protecci√≥n simult√°nea (entonces conviene mutex o cola).



---

üí° Ejercicio propuesto

Agreg√° una tercera tarea que:

Espere notificaciones de la tarea del sensor,

Pero solo encienda un LED si la temperatura supera los 28 ¬∞C.


üëâ Te sirve para practicar:

M√∫ltiples consumidores con diferentes comportamientos.

C√≥mo sincronizar tareas secundarias con una principal.



---

üß† Avance conceptual

Ahora domin√°s:

xTaskNotifyGive() y ulTaskNotifyTake() (forma simple).

Comunicaci√≥n uno a uno sin colas.

Bloqueo eficiente hasta recibir un evento.

C√≥mo evitar sobrecargar RAM con colas o sem√°foros.



---

‚úÖ Pr√≥ximo paso recomendado ‚Äî M√ìDULO 4:
Notificaciones con valores y eventos m√∫ltiples,
donde cada tarea puede recibir distintos eventos o tipos de dato codificados en la notificaci√≥n (bitfields o flags).


---

¬øQuer√©s que te arme ahora el M√≥dulo 4 (notificaciones con datos y eventos m√∫ltiples, m√°s avanzado)?