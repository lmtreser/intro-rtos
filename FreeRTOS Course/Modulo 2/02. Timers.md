# MÓDULO 2 — TEMPORIZACIÓN Y TIMERS DE SOFTWARE

## Objetivo

Aprender a generar **eventos periódicos precisos** sin necesidad de tareas dedicadas o `delay()`, usando **timers de software** gestionados por FreeRTOS.

## Conceptos clave

FreeRTOS tiene **dos maneras principales** de hacer tareas repetitivas:

| Método                             | Modo de uso                          | Recursos consumidos      | Ideal para                                                            |
| ---------------------------------- | ------------------------------------ | ------------------------ | --------------------------------------------------------------------- |
| `vTaskDelay()` dentro de una tarea | Repetición con espera                | Una tarea completa       | Procesos con lógica propia (lectura, cálculos, etc.)                  |
| **Timer de software**              | Llama una función cada cierto tiempo | Sin crear tarea dedicada | Acciones simples, cortas y periódicas (ej: leer sensor, togglear LED) |

## Estructura de un Timer FreeRTOS

Un timer de software tiene:

* un **manejador** (`TimerHandle_t`);
* un **período** (en ticks o ms);
* una **función de callback** (la que se ejecuta al vencer el tiempo);
* un modo:
    * **auto-reload** → se reinicia automáticamente,
    * **one-shot** → se ejecuta una sola vez.

## Proyecto 1: “Sensor periódico sin tareas extra”

**Objetivo:**
Leer el DHT22 cada 2 segundos, mostrar por `Serial` la temperatura y humedad.
Todo esto sin usar `vTaskDelay()` ni tareas dedicadas.

| Elemento                 | Rol                                         |
| ------------------------ | ------------------------------------------- |
| `xTimerCreate()`         | Crea el timer                               |
| `pdMS_TO_TICKS()`        | Convierte milisegundos a ticks del RTOS     |
| `xTimerStart()`          | Inicia el timer                             |
| `vSensorTimerCallback()` | Se ejecuta cada vencimiento                 |
| `pdTRUE`                 | Hace que el timer se repita automáticamente |

### Comparación

**Con tarea:**

```cpp
void TaskSensor(void* pv) {
  for (;;) {
    readSensor();
    vTaskDelay(pdMS_TO_TICKS(2000));
  }
}
```

**Con timer:**

* No necesitas crear una tarea.
* FreeRTOS ejecuta la función en contexto del *Timer Service Task*,
  que ya existe y gestiona todos los timers del sistema.

### Ventajas

- Menos consumo de RAM.
- Código más limpio.
- Ideal para rutinas cortas, repetitivas y no bloqueantes.

## Proyecto 2: Timer one-shot

**Objetivo:**
Ejecutar una acción una sola vez, luego de 5 segundos desde el arranque.

## Consideraciones técnicas

* Usar **timers** cuando solo sea necesario ejecutar *una pequeña acción* periódicamente.
* Usar **tareas** con `vTaskDelay()` cuando la lógica sea más compleja o interactúe con varios recursos (colas, semáforos, etc).
* No utilizar bloqueos (`delay()`, lecturas largas, prints enormes) dentro del callback del timer → FreeRTOS lo ejecuta en una tarea compartida.

## Ejercicio integrador

Extender el proyecto del DHT22:

1. Agregá un **segundo timer one-shot** que prenda un LED durante 3 segundos cuando la humedad supere el 60%.
2. Desde el callback del sensor, llamar a `xTimerStart(xOneShotTimer, 0);` cuando ocurra la condición.